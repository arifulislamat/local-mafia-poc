// ===========================================
// Network — PeerJS WebRTC Wrapper
// ===========================================

const Network = (() => {
  let peer = null;
  let conn = null;
  let isHost = false;
  let callbacks = {};
  let openPollTimer = null;
  let connected = false;

  // Generate a 6-character room code (no confusable chars)
  function generateRoomCode() {
    const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let code = "";
    for (let i = 0; i < 6; i++) {
      code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
  }

  const PEER_CONFIG = {
    debug: 2, // PeerJS debug level (0=none, 1=errors, 2=warnings, 3=all)
    config: {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
      ],
    },
  };

  // ---- Host: create a room and wait for guest ----
  function createHost(cbs) {
    isHost = true;
    connected = false;
    callbacks = cbs;
    const roomCode = generateRoomCode();
    const peerId = "p2p-shooter-" + roomCode;

    console.log("[Net] Creating host peer:", peerId);
    peer = new Peer(peerId, PEER_CONFIG);

    peer.on("open", (id) => {
      console.log("[Net] Host peer open, id:", id);
      if (callbacks.onReady) callbacks.onReady(roomCode);
    });

    peer.on("connection", (connection) => {
      console.log("[Net] Host received connection from guest");
      conn = connection;
      // Defer setup to let PeerJS finish its internal message processing
      setTimeout(() => setupConnection(), 0);
    });

    peer.on("error", (err) => {
      console.error("[Net] Host peer error:", err.type, err.message);
      const msg =
        err.type === "unavailable-id"
          ? "Room code already in use. Try again."
          : err.message || "Connection error";
      if (callbacks.onError) callbacks.onError(msg);
    });
  }

  // ---- Guest: join an existing room ----
  function joinGame(roomCode, cbs) {
    isHost = false;
    connected = false;
    callbacks = cbs;

    console.log("[Net] Creating guest peer...");
    peer = new Peer(PEER_CONFIG);

    peer.on("open", (id) => {
      console.log("[Net] Guest peer open, id:", id);
      const peerId = "p2p-shooter-" + roomCode.toUpperCase().trim();
      console.log("[Net] Connecting to host:", peerId);
      conn = peer.connect(peerId, {
        reliable: true,
        serialization: "json",
      });
      // Defer setup to let PeerJS finish its internal message processing
      setTimeout(() => setupConnection(), 0);
    });

    peer.on("error", (err) => {
      console.error("[Net] Guest peer error:", err.type, err.message);
      const msg =
        err.type === "peer-unavailable"
          ? "Room not found. Check the code and try again."
          : err.message || "Connection error";
      if (callbacks.onError) callbacks.onError(msg);
    });
  }

  // ---- Mark as connected (deduplicated) ----
  function markConnected() {
    if (connected) return;
    connected = true;
    clearPollTimer();
    console.log("[Net] ✓ DataChannel OPEN — connected!");
    if (callbacks.onConnected) callbacks.onConnected();
  }

  // ---- Poll for conn.open as fallback ----
  function startOpenPoll() {
    clearPollTimer();
    let attempts = 0;
    openPollTimer = setInterval(() => {
      attempts++;

      // Log state every second
      if (attempts % 10 === 0) {
        const dcState = conn && conn._dc ? conn._dc.readyState : "no _dc";
        const pcState =
          conn && conn.peerConnection
            ? conn.peerConnection.connectionState
            : "no pc";
        const iceState =
          conn && conn.peerConnection
            ? conn.peerConnection.iceConnectionState
            : "no pc";
        console.log(
          `[Net] Poll #${attempts}: conn.open=${conn?.open}, dc=${dcState}, pc=${pcState}, ice=${iceState}`,
        );
      }

      if (conn && conn.open) {
        console.log("[Net] Poll: conn.open=true after", attempts, "checks");
        markConnected();
        return;
      }

      // Check underlying DataChannel
      if (conn && conn._dc && conn._dc.readyState === "open") {
        console.log("[Net] Poll: _dc open after", attempts, "checks");
        markConnected();
        return;
      }

      // Check underlying PeerConnection
      if (conn && conn.peerConnection) {
        const pc = conn.peerConnection;
        if (pc.connectionState === "connected" || pc.iceConnectionState === "connected") {
          // PC connected but DataChannel not open yet — wait a bit more
          if (attempts > 5 && conn._dc) {
            console.log("[Net] PC connected, dc state:", conn._dc.readyState);
          }
        }
        if (pc.connectionState === "failed" || pc.iceConnectionState === "failed") {
          console.error("[Net] ICE connection failed!");
          clearPollTimer();
          if (callbacks.onError) callbacks.onError("Connection failed — try again");
          return;
        }
      }

      if (attempts > 150) {
        console.error("[Net] Connection poll timed out (15s)");
        clearPollTimer();
        if (callbacks.onError) callbacks.onError("Connection timed out — try again");
      }
    }, 100);
  }

  function clearPollTimer() {
    if (openPollTimer) {
      clearInterval(openPollTimer);
      openPollTimer = null;
    }
  }

  // ---- Set up connection event handlers ----
  function setupConnection() {
    console.log("[Net] Setting up connection, conn.open:", conn.open);

    // Immediate check
    if (conn.open) {
      markConnected();
    }

    // Event-based detection
    conn.on("open", () => {
      console.log("[Net] conn 'open' event fired");
      markConnected();
    });

    conn.on("data", (data) => {
      if (!connected) {
        console.log("[Net] Got data before open event — marking connected");
        markConnected();
      }
      if (callbacks.onData) callbacks.onData(data);
    });

    conn.on("close", () => {
      console.log("[Net] Connection closed");
      clearPollTimer();
      if (callbacks.onDisconnected) callbacks.onDisconnected();
    });

    conn.on("error", (err) => {
      console.error("[Net] Connection error:", err);
      if (callbacks.onError)
        callbacks.onError(err.message || "Connection error");
    });

    // Also monitor the underlying DataChannel directly if available
    if (conn._dc) {
      console.log("[Net] _dc exists at setup, state:", conn._dc.readyState);
      conn._dc.addEventListener("open", () => {
        console.log("[Net] _dc 'open' event fired directly");
        markConnected();
      });
    }

    // Monitor underlying PeerConnection ICE state
    if (conn.peerConnection) {
      console.log("[Net] peerConnection exists at setup");
      conn.peerConnection.addEventListener("connectionstatechange", () => {
        console.log("[Net] PC connectionState:", conn.peerConnection.connectionState);
      });
      conn.peerConnection.addEventListener("iceconnectionstatechange", () => {
        console.log("[Net] PC iceConnectionState:", conn.peerConnection.iceConnectionState);
      });
      // Watch for datachannel event (host side)
      conn.peerConnection.addEventListener("datachannel", (e) => {
        console.log("[Net] PC datachannel event, state:", e.channel.readyState);
        e.channel.addEventListener("open", () => {
          console.log("[Net] PC datachannel opened directly");
          markConnected();
        });
      });
    }

    // Start polling as fallback
    startOpenPoll();
  }

  // ---- Send data to peer ----
  function send(data) {
    if (conn && conn.open) {
      conn.send(data);
    }
  }

  // ---- Clean up ----
  function disconnect() {
    clearPollTimer();
    connected = false;
    if (conn) {
      conn.close();
      conn = null;
    }
    if (peer) {
      peer.destroy();
      peer = null;
    }
    callbacks = {};
  }

  function getIsHost() {
    return isHost;
  }

  function isConnected() {
    return connected && conn && conn.open;
  }

  return {
    createHost,
    joinGame,
    send,
    disconnect,
    getIsHost,
    isConnected,
  };
})();
